  *ROS2 Basics in 5 days C++ *

Alguns comandos obvios nao serão postos nesse resumo, pois, antes foi feito curso de ros2 em pyhon, que eh semelhante.
launch folder: Contains launch files
src folder: Contains source files (CPP, Python)
CMakeLists.txt: List of Cmake rules for compilation
package.xml: Package metadata and dependencies

    *First package*
dentro do src do workskpace:
ros2 pkg create <package_name> --build-type ament_cmake --dependencies <package_dependencies> 
ros2 pkg create my_package --build-type ament_cmake --dependencies rclcpp  (exemplo)

depois colcon build no ws ou colcon build --packages-select <package_name>
e source install/setup.bash

  *launch*

ao criar um file em python dentro do launch tem que ser <.launch.py> , exemplo: touch my_package_launch_file.launch.py 

ao executar <ros2 launch my_package my_package_launch_file.launch.py> estamos pegando o py dentro do launch dentro do my_package , então, dentro do my_package eh onde o launch esta 

*exemplo de codigo .cpp dentro do src dentro do folder:

#include "rclcpp/rclcpp.hpp"

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  auto node = rclcpp::Node::make_shared("ObiWan");
  // We create a Rate object of 2Hz
  rclcpp::WallRate loop_rate(2);

  // Endless loop until Ctrl + C
  while (rclcpp::ok()) {

    RCLCPP_INFO(node->get_logger(), "Help me Obi-Wan Kenobi, you're my only hope");
    rclcpp::spin_some(node);
    // We sleep the needed time to maintain the Rate fixed above
    loop_rate.sleep();
        
  }
  rclcpp::shutdown();
  return 0;
}
// This program creates an endless loop that repeats itself 2 times per second (2Hz) until somebody presses Ctrl + C
// in the Shell

*exemplo  do cmakelist dentro do src dentro do folder:

cmake_minimum_required(VERSION 3.8)
project(my_package)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  # the following line skips the linter which checks for copyrights
  # uncomment the line when a copyright and license is not present in all source files
  #set(ament_cmake_copyright_FOUND TRUE)
  # the following line skips cpplint (only works in a git repo)
  # uncomment the line when this package is not in a git repo
  #set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()
endif()

add_executable(simple_node src/simple.cpp)
ament_target_dependencies(simple_node rclcpp)

install(TARGETS
   simple_node
   DESTINATION lib/${PROJECT_NAME}
 )

install(DIRECTORY
  launch
  DESTINATION share/${PROJECT_NAME}/
)

ament_package()

*Arquivo.py dentro do launch :

from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_package',
            executable='simple_node',
            output='screen'),
    ])

          *RESUMO ESSECENCIAL*

Estrutura de pastas - Workspace > src > Pasta1(com dependendcia em c++) > src e launch (src - codigos C++ / launch - codigo .launch.py) obs: dentro da pasta dependente criada antes, alem do src e launch 
tem cmake.txt e package.xml , o .txt deve ser alterado adicionando o executavel para rodar o codigo 

Após executar o launch , um topico foi ativado, se der ros2 topic list | grep '/counter' , vemos que esse foi o topico de exemplo que foi ativado.
ros2 topic info /counter vai dizer quantos publishers e subscriptions foram ativados nesse topic
e ros2 topic echo /counter vai mostrar o output em tempo real doq ta rolando e ros2 interface show std_msgs/msg/Int32 mostra interface

      *Classes em c++*

exemplo de codigo :

#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/int32.hpp"
#include <chrono>

using namespace std::chrono_literals;

/* This example creates a subclass of Node and uses std::bind() to register a
 * member function as a callback from the timer. */

class SimplePublisher : public rclcpp::Node
{
public:
  SimplePublisher()
  : Node("simple_publisher"), count_(0)
  {
    publisher_ = this->create_publisher<std_msgs::msg::Int32>("counter", 10);
    timer_ = this->create_wall_timer(
      500ms, std::bind(&SimplePublisher::timer_callback, this));
  }

private:
  void timer_callback()
  {
    auto message = std_msgs::msg::Int32();
    message.data = count_;
    count_++;
    publisher_->publish(message);
  }
  rclcpp::TimerBase::SharedPtr timer_;
  rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr publisher_;
  size_t count_;
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<SimplePublisher>());
  rclcpp::shutdown();
  return 0;
}


 
